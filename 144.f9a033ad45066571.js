"use strict";(self.webpackChunkgelenium_ui_demo=self.webpackChunkgelenium_ui_demo||[]).push([[144],{8144:(y,g,a)=>{a.r(g),a.d(g,{DrRegexCheckModule:()=>R});var c=a(6895),l=a(433),h=a(811),u=a(7084),p=a(3848),d=a(9544),e=a(1571);let b=(()=>{class t{}return t.\u0275fac=function(r){return new(r||t)},t.\u0275mod=e.oAB({type:t}),t.\u0275inj=e.cJS({imports:[c.ez,l.UX,h.vV,u.To,p.Nh,d.eB,d.rw]}),t})(),v=(()=>{class t{}return t.\u0275fac=function(r){return new(r||t)},t.\u0275mod=e.oAB({type:t}),t.\u0275inj=e.cJS({imports:[c.ez]}),t})();var m=a(6001),T=a(590),U=a(4577),s=a(4171),i=a(6986);const x=function(){return{checkLetters:"^(?=.*[a-zA-Z])[\\w\\W]{1,}$",checkDigits:"^(?=.*\\d)[\\w\\W]{1,}$",checkSymbols:"^(?=.*[!@#$%^&*])[\\w\\W]{1,}$"}};let f=(()=>{class t{constructor(){this.labelShowSource=i.sx,this.labelOutlined=i.SR,this.labelUnderline=i.kP,this.labelStandard=i.Qb,this.labelHtml=i.zC,this.labelTs=i.QS,this.labelCss=i.Er,this.baseRef=s.g.get("BASE_REF"),this.urlDrRegexCheck=this.baseRef+"/"+s.g.get("URL_DIRECTIVES")+"/"+s.g.get("URL_DIRECTIVES_REGEX_CHECK"),this.control01a={model01a:new l.NI("1",[])},this.formGroup01a=new l.cw(this.control01a),this.exterior01b="outlined",this.control01b={model01b:new l.NI("",[]),model01c:new l.NI("",[]),model01d:new l.NI("01/0",[]),model01e:new l.NI("01/0",[]),model01f:new l.NI("(99",[])},this.formGroup01b=new l.cw(this.control01b)}}return t.\u0275fac=function(r){return new(r||t)},t.\u0275cmp=e.Xpm({type:t,selectors:[["app-dr-regex-check-basic"]],inputs:{labelShowSource:"labelShowSource",labelOutlined:"labelOutlined",labelUnderline:"labelUnderline",labelStandard:"labelStandard",labelHtml:"labelHtml",labelTs:"labelTs",labelCss:"labelCss"},decls:275,vars:37,consts:[["mr-vr",""],[1,"app-hover-link"],[3,"href"],["href","https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern","target","_blank"],["source","html"],["novalidate","","autocomplete","off",3,"formGroup"],[1,"app-group"],[1,"app-elem"],["type","text","formControlName","model01a","pattern","[A-Za-z]{1,3}",1,"rcb-input"],["id","gln-regex-check1",1,"app-hover-link"],["id","gln-regex-check2",1,"app-hover-link"],["id","gln-regex-check3",1,"app-hover-link"],["id","gln-regex-check4",1,"app-hover-link"],["value","exterior01b",3,"change"],["value","outlined",3,"checked"],["value","underline",3,"checked"],["value","standard",3,"checked"],["formControlName","model01b","wdFull","","pattern","(?=.*[a-zA-Z])[a-zA-Z\\d]{1,}","glnRegexCheck","(?=.*\\d)[a-zA-Z\\d]{1,}",3,"label","helperText","exterior"],["formControlName","model01c","wdFull","",3,"label","glnRegexCheck","helperText","exterior"],["formControlName","model01d","wdFull","","glnRegexCheck","/^[0-9]{2}[\\/][0-9]{2}[\\/][0-9]{4}$/i",3,"label","helperText","exterior"],["formControlName","model01e","wdFull","","glnRegexCheck","/^([0-9]{0,2}|[0-9]{2}[\\/]([0-9]{0,2}|[0-9]{2}[\\/][0-9]{0,4}))$/i",3,"label","helperText","exterior"],["formControlName","model01f","wdFull","","glnRegexCheck","/^([(][0-9]{0,3}|[(][0-9]{3}[)]([0-9]{0,3}|[0-9]{3}[-][0-9]{0,4}))$/i",3,"label","helperText","exterior"],["animationDuration","0ms"],[3,"label"],["source","ts"],["source","css"]],template:function(r,n){1&r&&(e.TgZ(0,"section",0)(1,"h3",1),e._uU(2," Basic. "),e.TgZ(3,"a",2),e._uU(4,"#"),e.qZA()(),e.TgZ(5,"p"),e._uU(6," The GlnRegexCheck directive implements checking the value of an element against a regular expression. Sometimes you want to restrict user input to some kind of business logic. To do this, you can use the "),e.TgZ(7,"a",3),e._uU(8,'"pattern"'),e.qZA(),e._uU(9," attribute of the native input element. "),e.qZA(),e.TgZ(10,"p"),e._uU(11," For example, an input field can contain up to three letters. "),e.qZA(),e.TgZ(12,"code")(13,"pre",4),e._uU(14,'<style>\n  input.rcb-input.ng-invalid {\n    border: red solid 2px;\n    outline-color: red;\n  }\n</style>\n\n<form [formGroup]="formGroup01a"\n  novalidate\n  autocomplete="off">\n\n  <div class="app-group">\n    <div class="app-elem">\n      <div>\n        <small>\n          <em>pattern="[A-Za-z]{1,3}".</em>\n        </small>\n      </div>\n      <input class="rcb-input"\n        type="text"\n        formControlName="model01a"\n        pattern="[A-Za-z]{1,3}" />\n      <code>\n      <small>\n        <pre>errors='),e.TgZ(15,"b"),e._uU(16,"{"),e.qZA(),e._uU(17,"{ control01a.model01a.errors | json }}</pre>\n      </small>\n    </code>\n    </div>\n  </div>\n\n</form>"),e.qZA()()(),e.TgZ(18,"form",5)(19,"div",6)(20,"div",7)(21,"div")(22,"small")(23,"em"),e._uU(24,'pattern="[A-Za-z]{1,3}".'),e.qZA()()(),e._UZ(25,"input",8),e.TgZ(26,"code")(27,"small")(28,"pre"),e._uU(29),e.ALo(30,"json"),e.qZA()()()()()(),e.TgZ(31,"section",0)(32,"h4",9),e._uU(33,' 2. Use a "pattern" with RegExp and GlnRegexCheck. '),e.TgZ(34,"a",2),e._uU(35,"#"),e.qZA()(),e.TgZ(36,"p"),e._uU(37,' But there are situations when you need to apply several restrictions and display a separate error for each. In such cases, you can use the "GlnRegexCheck" directive. '),e.qZA(),e.TgZ(38,"p"),e._uU(39,' Let\'s consider the case that only letters and numbers can be valid, and otherwise - an error. To fulfill the condition contains letters, apply the "pattern" attribute. And to fulfill the condition contains digits, apply the "GlnRegexCheck" directive. '),e.qZA(),e.TgZ(40,"p"),e._uU(41," Let's prepare a regular expression to check for the presence of letters. Since we can have digits in addition to letters, this must be taken into account in the regular expression. Our expression has two parts: "),e.qZA(),e.TgZ(42,"ul")(43,"li"),e._uU(44,"expression "),e.TgZ(45,"code"),e._uU(46,"(?=.*[a-zA-Z])"),e.qZA(),e._uU(47," - checks for letters;"),e.qZA(),e.TgZ(48,"li"),e._uU(49,"expression "),e.TgZ(50,"code"),e._uU(51,"[a-zA-Z\\d]{1,}"),e.qZA(),e._uU(52," - contains a set of valid characters (at least one); "),e.qZA()(),e.TgZ(53,"p"),e._uU(54,"As a result, we get:"),e.qZA(),e.TgZ(55,"ul")(56,"li"),e._uU(57,"expression "),e.TgZ(58,"code"),e._uU(59,"^(?=.*[a-zA-Z])[a-zA-Z\\d]{1,}$"),e.qZA(),e._uU(60," - condition check contains letters;"),e.qZA(),e.TgZ(61,"li"),e._uU(62,"expression "),e.TgZ(63,"code"),e._uU(64,"^(?=.*[\\d])[a-zA-Z\\d]{1,}$"),e.qZA(),e._uU(65," - condition check contains digits;"),e.qZA()(),e.TgZ(66,"p"),e._uU(67,' The "GlnRegexCheck" directive supports the following forms for describing regular expressions: '),e.qZA(),e.TgZ(68,"ul")(69,"li")(70,"code"),e._uU(71,'glnRegexCheck="^-?(\\d+)$"'),e.qZA()(),e.TgZ(72,"li")(73,"code"),e._uU(74,"[glnRegexCheck]=\"'^-?(\\\\d+)$'\""),e.qZA()(),e.TgZ(75,"li")(76,"code"),e._uU(77,'glnRegexCheck="/^-?(\\d+)$/i"'),e.qZA()(),e.TgZ(78,"li")(79,"code"),e._uU(80,"[glnRegexCheck]=\"'/^-?(\\\\d+)$/i'\""),e.qZA()()(),e.TgZ(81,"p"),e._uU(82,' If the value does not match the regular expression, then the "regexCheck" property is displayed in the error object (this is the default value). '),e.qZA(),e.TgZ(83,"p"),e._uU(84,' Let\'s say we need to apply three or more constraints on the value of an input field. The methods described earlier will not work here. But we can apply the "GlnRegexCheck" directive with the configuration. This directive as an input parameter can accept an object with fields: key, value. The key is the name of the property in the error object. The value is a regular expression string. '),e.qZA()(),e.TgZ(85,"section",0)(86,"h4",10),e._uU(87," 3. GlnRegexCheck configuration. "),e.TgZ(88,"a",2),e._uU(89,"#"),e.qZA()(),e.TgZ(90,"p"),e._uU(91," Suppose we need to define a new secret key (or password). The field value can contain various characters. The following conditions must be met: "),e.qZA(),e.TgZ(92,"ul")(93,"li"),e._uU(94,"letters must be present"),e.qZA(),e.TgZ(95,"li"),e._uU(96,"digits must be present:"),e.qZA(),e.TgZ(97,"li"),e._uU(98,'symbols must be present: "!@#$%^&*"'),e.qZA()(),e.TgZ(99,"p"),e._uU(100," Let's prepare a regular expression to check for the presence of letters. Our expression has two parts: "),e.qZA(),e.TgZ(101,"ul")(102,"li"),e._uU(103,"expression "),e.TgZ(104,"code"),e._uU(105,"(?=.*[a-zA-Z])"),e.qZA(),e._uU(106," - checks for letters;"),e.qZA(),e.TgZ(107,"li"),e._uU(108,"expression "),e.TgZ(109,"code"),e._uU(110,"[\\w\\W]{1,}"),e.qZA(),e._uU(111," - contains all possible characters (at least one);"),e.qZA()(),e.TgZ(112,"p")(113,"code"),e._uU(114," \\w - Matches any letter, digit or underscore."),e._UZ(115,"br"),e._uU(116," Equivalent to [a-zA-Z0-9_]."),e._UZ(117,"br"),e._uU(118," \\W - Matches anything other than a letter, digit or underscore."),e._UZ(119,"br"),e._uU(120," Equivalent to [^a-zA-Z0-9_] "),e.qZA()(),e.TgZ(121,"p"),e._uU(122,"As a result, we get:"),e.qZA(),e.TgZ(123,"ul")(124,"li"),e._uU(125,"expression "),e.TgZ(126,"code"),e._uU(127,"^(?=.*[a-zA-Z])[\\w\\W]{1,}$"),e.qZA(),e._uU(128," - condition check contains letters;"),e.qZA(),e.TgZ(129,"li"),e._uU(130,"expression "),e.TgZ(131,"code"),e._uU(132,"^(?=.*[\\d])[\\w\\W]{1,}$"),e.qZA(),e._uU(133," - condition check contains digits;"),e.qZA(),e.TgZ(134,"li"),e._uU(135," expression "),e.TgZ(136,"code"),e._uU(137,"^(?=.*[!@#$%^&*])[\\w\\W]{1,}$"),e.qZA(),e._uU(138,' - condition check contains symbols: "!@#$%^&*"; '),e.qZA()(),e.TgZ(139,"p"),e._uU(140," Thus, the application of the directive is as follows: "),e.qZA(),e.TgZ(141,"code")(142,"pre",4),e._uU(143,"    [glnRegexCheck]=\"{\n      'checkLetters': '^(?=.*[a-zA-Z])[\\\\w\\\\W]{1,}$',\n      'checkDigits': '^(?=.*\\\\d)[\\\\w\\\\W]{1,}$',\n      'checkSymbols': '^(?=.*[!@#$%^&*])[\\\\w\\\\W]{1,}$'\n    }\""),e.qZA()()(),e.TgZ(144,"section",0)(145,"h4",11),e._uU(146,' 4. "GlnRegexCheck" and date input. '),e.TgZ(147,"a",2),e._uU(148,"#"),e.qZA()(),e.TgZ(149,"p"),e._uU(150," Let's say we need to implement an initial check for entering a date value. Let's prepare a regular expression:"),e._UZ(151,"br"),e.TgZ(152,"code"),e._uU(153,"^[0-9]{2}[\\/][0-9]{2}[\\/][0-9]{4}$"),e.qZA(),e._UZ(154,"br"),e._uU(155," On testing, we can see that an error is displayed when entering a date value. And only when you enter the last digit, the error message disappears. This behavior is not entirely user-friendly. And we understand that a regular expression should be able to enter the value gradually. "),e.qZA(),e.TgZ(156,"p"),e._uU(157," Let's take another regular expression:"),e._UZ(158,"br"),e.TgZ(159,"code"),e._uU(160," ^([0-9]{0,2}|[0-9]{2}[\\/]([0-9]{0,2}|[0-9]{2}[\\/][0-9]{0,4}))$ "),e.qZA(),e._UZ(161,"br"),e._uU(162," Let's consider this expression in more detail. An expression has two main parts."),e._UZ(163,"br"),e._uU(164," First part "),e.TgZ(165,"code"),e._uU(166,"[0-9]{0,2}"),e.qZA(),e._uU(167,"."),e._UZ(168,"br"),e._uU(169," This expression allows you to enter the first number between 0 and 2 digits."),e._UZ(170,"br"),e._uU(171," Second part "),e.TgZ(172,"code"),e._uU(173," [0-9]{2}[\\/]([0-9]{0,2}|[0-9]{2}[\\/][0-9]{0,4}) "),e.qZA(),e._uU(174,"."),e._UZ(175,"br"),e._uU(176," The first snippet "),e.TgZ(177,"code"),e._uU(178,"[0-9]{2}[\\/]"),e.qZA(),e._uU(179," assumes that the first two-digit number and the forward slash have already been entered."),e._UZ(180,"br"),e._uU(181," Next in parentheses is the second snippet "),e.TgZ(182,"code"),e._uU(183,"[0-9]{0,2}|[0-9]{2}[\\/][0-9]{0,4}"),e.qZA(),e._uU(184,"."),e._UZ(185,"br"),e._uU(186," In this snippet, we again see two component parts. The first part "),e.TgZ(187,"code"),e._uU(188,"[0-9]{0,2}"),e.qZA(),e._uU(189," allows you to enter the second number between 0 and 2 digits. "),e._UZ(190,"br"),e._uU(191," And when this number is entered successfully, the second component becomes active "),e.TgZ(192,"code"),e._uU(193,"[0-9]{2}[\\/][0-9]{0,4}"),e.qZA(),e._uU(194,". This allows the next number from 0 to 4 digits to be entered."),e._UZ(195,"br"),e._uU(196," Therefore, the user can enter the date value gradually and without an error message. "),e.qZA()(),e.TgZ(197,"section",0)(198,"h4",12),e._uU(199," 5. Entering a phone number. "),e.TgZ(200,"a",2),e._uU(201,"#"),e.qZA()(),e.TgZ(202,"p"),e._uU(203," Let's say we need to implement validation of entering a phone number value in the format \""),e.TgZ(204,"code"),e._uU(205,"(999)999-9999"),e.qZA(),e._uU(206,'". The regular expression that checks this format is:'),e._UZ(207,"br"),e.TgZ(208,"code"),e._uU(209,"^[(][0-9]{3}[)][0-9]{3}[-][0-9]{4}$"),e.qZA(),e._UZ(210,"br"),e._uU(211," And here is a regular expression that allows you to enter this format sequentially:"),e._UZ(212,"br"),e.TgZ(213,"code"),e._uU(214,"^([(][0-9]{0,3}|[(][0-9]{3}[)]([0-9]{0,3}|[0-9]{3}[-][0-9]{0,4}))$"),e.qZA(),e._UZ(215,"br"),e.qZA(),e._UZ(216,"p"),e.qZA(),e.TgZ(217,"section",0)(218,"span"),e._uU(219,"exterior: "),e.qZA(),e.TgZ(220,"mat-button-toggle-group",13),e.NdJ("change",function(q){return n.exterior01b=q.value}),e.TgZ(221,"mat-button-toggle",14),e._uU(222),e.qZA(),e.TgZ(223,"mat-button-toggle",15),e._uU(224),e.qZA(),e.TgZ(225,"mat-button-toggle",16),e._uU(226),e.qZA()()(),e.TgZ(227,"form",5)(228,"div",6)(229,"div",7)(230,"div")(231,"small")(232,"em"),e._uU(233,'2. pattern="[a-zA-Z]", glnRegexCheck="\\d".'),e.qZA()()(),e._UZ(234,"gln-input",17),e.qZA(),e.TgZ(235,"div",7)(236,"div")(237,"small")(238,"em"),e._uU(239,"3. Check: [a-zA-Z], [\\d], [!@#$%^&*]."),e.qZA()()(),e._UZ(240,"gln-input",18),e.qZA(),e.TgZ(241,"div",7)(242,"div")(243,"small")(244,"em"),e._uU(245,"4.a. Entering a date value."),e.qZA()()(),e._UZ(246,"gln-input",19),e.qZA(),e.TgZ(247,"div",7)(248,"div")(249,"small")(250,"em"),e._uU(251,"4.b. Entering a date value."),e.qZA()()(),e._UZ(252,"gln-input",20),e.qZA(),e.TgZ(253,"div",7)(254,"div")(255,"small")(256,"em"),e._uU(257,"5. Entering a phone number."),e.qZA()()(),e._UZ(258,"gln-input",21),e.qZA()()(),e.TgZ(259,"section",0)(260,"mat-accordion")(261,"mat-expansion-panel")(262,"mat-expansion-panel-header")(263,"mat-panel-title"),e._uU(264),e.qZA()(),e.TgZ(265,"mat-tab-group",22)(266,"mat-tab",23)(267,"pre",4),e._uU(268,"<form [formGroup]=\"formGroup01b\"\n  novalidate\n  autocomplete=\"off\">\n\n  <div class=\"app-group\">\n\n    <div class=\"app-elem\">\n      <div>\n        <small>\n          <em>2. pattern=\"[a-zA-Z]\", glnRegexCheck=\"\\d\".</em>\n        </small>\n      </div>\n      <gln-input formControlName=\"model01b\"\n        wdFull\n        [label]=\"!control01b.model01b.value\n          ?'Enter a digit and symbol':'A digit and symbol'\"\n        pattern=\"(?=.*[a-zA-Z])[a-zA-Z\\d]{1,}\"\n        glnRegexCheck=\"(?=.*\\d)[a-zA-Z\\d]{1,}\"\n        [helperText]=\"\n        !control01b.model01b.errors\n        ?(!control01b.model01b.value\n          ? 'Enter value.':'The value is correct.'\n         )\n        :(control01b.model01b.errors!['pattern']\n          ? 'The field must have characters.'\n          : (control01b.model01b.errors!['regexCheck']\n             ?'The field must have digits.'\n             :'The value is not correct.')\n         )\"\n        [exterior]=\"exterior01b\">\n      </gln-input>\n    </div>\n\n    <div class=\"app-elem\">\n      <div>\n        <small>\n          <em>3. Check: [a-zA-Z], [\\d], [!@#$%^&*].</em>\n        </small>\n      </div>\n      <gln-input formControlName=\"model01c\"\n        wdFull\n        [label]=\"!control01b.model01c.value\n          ?'Enter parameter':'Parameter'\"\n        [glnRegexCheck]=\"{\n          'checkLetters': '^(?=.*[a-zA-Z])[\\\\w\\\\W]{1,}$',\n          'checkDigits': '^(?=.*\\\\d)[\\\\w\\\\W]{1,}$',\n          'checkSymbols': '^(?=.*[!@#$%^&*])[\\\\w\\\\W]{1,}$'\n        }\"\n        [helperText]=\"\n        !control01b.model01c.errors\n        ?(!control01b.model01c.value\n          ? 'Enter the parameter.':'The value is correct.'\n         )\n        :(control01b.model01c.errors['checkLetters']\n          ?'Letters must be present'\n          :(control01b.model01c.errors['checkDigits']\n             ?'Digits must be present.'\n             :(control01b.model01c.errors['checkSymbols']\n               ?'Must be characters from the set [!@#$%^&*].'\n               :'The value is not correct.'\n              )\n            )\n         )\"\n        [exterior]=\"exterior01b\">\n      </gln-input>\n    </div>\n\n    <div class=\"app-elem\">\n      <div>\n        <small>\n          <em>4.a. Entering a date value.</em>\n        </small>\n      </div>\n      <gln-input formControlName=\"model01d\"\n        wdFull\n        [label]=\"!control01b.model01d.value\n          ?'Enter the date':'Date value.'\"\n        glnRegexCheck=\"/^[0-9]{2}[\\/][0-9]{2}[\\/][0-9]{4}$/i\"\n        [helperText]=\"\n        !control01b.model01d.errors\n        ?(!control01b.model01d.value\n          ? 'Enter a date value.':'The date value is correct.'\n         )\n        :(control01b.model01d.errors!['regexCheck']\n          ? 'The value should be \\'01/01/2021\\'.'\n          : 'The value is not correct.'\n         )\"\n        [exterior]=\"exterior01b\">\n      </gln-input>\n    </div>\n\n    <div class=\"app-elem\">\n      <div>\n        <small>\n          <em>4.b. Entering a date value.</em>\n        </small>\n      </div>\n      <gln-input formControlName=\"model01e\"\n        wdFull\n        [label]=\"!control01b.model01e.value\n          ?'Enter the date':'Date value.'\"\n        glnRegexCheck=\"/^([0-9]{0,2}|[0-9]{2}[\\/]([0-9]{0,2}|[0-9]{2}[\\/][0-9]{0,4}))$/i\"\n        [helperText]=\"\n        !control01b.model01e.errors\n        ?(!control01b.model01e.value\n          ? 'Enter a date value.':'The date value is correct.'\n         )\n        :(control01b.model01e.errors!['regexCheck']\n          ? 'The value should be \\'01/01/2021\\'.'\n          : 'The value is not correct.'\n         )\"\n        [exterior]=\"exterior01b\">\n      </gln-input>\n    </div>\n\n    <div class=\"app-elem\">\n      <div>\n        <small>\n          <em>5. Entering a phone number.</em>\n        </small>\n      </div>\n      <gln-input formControlName=\"model01f\"\n        wdFull\n        [label]=\"!control01b.model01f.value\n          ?'Enter a phone number.':'Phone number.'\"\n        glnRegexCheck=\"/^([(][0-9]{0,3}|[(][0-9]{3}[)]([0-9]{0,3}|[0-9]{3}[-][0-9]{0,4}))$/i\"\n        [helperText]=\"\n        !control01b.model01f.errors\n        ?(!control01b.model01f.value\n          ? 'Enter a phone number.':'The phone number is correct.'\n         )\n        :(control01b.model01f.errors!['regexCheck']\n          ? 'The phone number should be \\'(999)999-9999\\'.'\n          : 'The phone number is not correct.'\n         )\"\n        [exterior]=\"exterior01b\">\n      </gln-input>\n    </div>\n\n  </div>\n\n</form>"),e.qZA()(),e.TgZ(269,"mat-tab",23)(270,"pre",24),e._uU(271,"import {\n  Component, ViewEncapsulation\n} from '@angular/core';\nimport {\n  FormControl, FormGroup, Validators\n} from '@angular/forms';\n\n@Component({\n  selector: 'app-regex',\n  templateUrl: './regex.component.html',\n  styleUrls: ['./regex.component.scss'],\n  encapsulation: ViewEncapsulation.None,\n})\nexport class RegexComponent {\n  public demo01 = '1';\n  public control01b = {\n    model01b: new FormControl('', []),\n    model01c: new FormControl('', []),\n    model01d: new FormControl('01/0', []),\n    model01e: new FormControl('01/0', []),\n    model01f: new FormControl('(99', []),\n  };\n  public formGroup01b: FormGroup = new FormGroup(this.control01b);\n  public exterior01b = 'outlined';\n}"),e.qZA()(),e.TgZ(272,"mat-tab",23)(273,"pre",25),e._uU(274,".app-group {\n  display: flex;\n  flex-wrap: wrap;\n}\n.app-elem {\n  min-width: 26ch;\n  margin: 10px 10px;\n}"),e.qZA()()()()()()),2&r&&(e.xp6(3),e.Q6J("href",n.urlDrRegexCheck+"#Basic",e.LSH),e.xp6(15),e.Q6J("formGroup",n.formGroup01a),e.xp6(11),e.hij("errors=",e.lcZ(30,34,n.control01a.model01a.errors),""),e.xp6(5),e.Q6J("href",n.urlDrRegexCheck+"#gln-regex-check1",e.LSH),e.xp6(54),e.Q6J("href",n.urlDrRegexCheck+"#gln-regex-check2",e.LSH),e.xp6(59),e.Q6J("href",n.urlDrRegexCheck+"#gln-regex-check3",e.LSH),e.xp6(53),e.Q6J("href",n.urlDrRegexCheck+"#gln-regex-check4",e.LSH),e.xp6(21),e.Q6J("checked","outlined"===n.exterior01b),e.xp6(1),e.Oqu(n.labelOutlined),e.xp6(1),e.Q6J("checked","underline"===n.exterior01b),e.xp6(1),e.Oqu(n.labelUnderline),e.xp6(1),e.Q6J("checked","standard"===n.exterior01b),e.xp6(1),e.Oqu(n.labelStandard),e.xp6(1),e.Q6J("formGroup",n.formGroup01b),e.xp6(7),e.Q6J("label",n.control01b.model01b.value?"A digit and symbol":"Enter a digit and symbol")("helperText",n.control01b.model01b.errors?n.control01b.model01b.errors.pattern?"The field must have characters.":n.control01b.model01b.errors.regexCheck?"The field must have digits.":"The value is not correct.":n.control01b.model01b.value?"The value is correct.":"Enter value.")("exterior",n.exterior01b),e.xp6(6),e.Q6J("label",n.control01b.model01c.value?"Parameter":"Enter parameter")("glnRegexCheck",e.DdM(36,x))("helperText",n.control01b.model01c.errors?n.control01b.model01c.errors.checkLetters?"Letters must be present":n.control01b.model01c.errors.checkDigits?"Digits must be present.":n.control01b.model01c.errors.checkSymbols?"Must be characters from the set [!@#$%^&*].":"The value is not correct.":n.control01b.model01c.value?"The value is correct.":"Enter the parameter.")("exterior",n.exterior01b),e.xp6(6),e.Q6J("label",n.control01b.model01d.value?"Date value.":"Enter the date")("helperText",n.control01b.model01d.errors?n.control01b.model01d.errors.regexCheck?"The value should be '01/01/2021'.":"The value is not correct.":n.control01b.model01d.value?"The date value is correct.":"Enter a date value.")("exterior",n.exterior01b),e.xp6(6),e.Q6J("label",n.control01b.model01e.value?"Date value.":"Enter the date")("helperText",n.control01b.model01e.errors?n.control01b.model01e.errors.regexCheck?"The value should be '01/01/2021'.":"The value is not correct.":n.control01b.model01e.value?"The date value is correct.":"Enter a date value.")("exterior",n.exterior01b),e.xp6(6),e.Q6J("label",n.control01b.model01f.value?"Phone number.":"Enter a phone number.")("helperText",n.control01b.model01f.errors?n.control01b.model01f.errors.regexCheck?"The phone number should be '(999)999-9999'.":"The phone number is not correct.":n.control01b.model01f.value?"The phone number is correct.":"Enter a phone number.")("exterior",n.exterior01b),e.xp6(6),e.Oqu(n.labelShowSource),e.xp6(2),e.Q6J("label",n.labelHtml),e.xp6(3),e.Q6J("label",n.labelTs),e.xp6(3),e.Q6J("label",n.labelCss))},dependencies:[l._Y,l.Fj,l.JJ,l.JL,l.c5,l.sg,l.u,h.A9,h.Yi,u.pp,u.ib,u.yz,u.yK,p.SP,p.uX,d.j7,d.f7,c.Ts],styles:["app-dr-regex-check-basic{display:block}\n","\n  input.rcb-input.ng-invalid {\n    border: red solid 2px;\n    outline-color: red;\n  }\n"],encapsulation:2,changeDetection:0}),t})(),A=(()=>{class t{constructor(){this.baseRef=s.g.get("BASE_REF"),this.urlDrRegexCheck=this.baseRef+"/"+s.g.get("URL_DIRECTIVES")+"/"+s.g.get("URL_DIRECTIVES_REGEX_CHECK")}}return t.\u0275fac=function(r){return new(r||t)},t.\u0275cmp=e.Xpm({type:t,selectors:[["app-dr-regex-check-api"]],decls:81,vars:3,consts:[["mr-vr",""],[1,"app-hover-link"],[3,"href"],["fw500",""],["id","properties",1,"app-hover-link"],[1,"app-tab"],[1,"app-mn-wd-22ch"],["id","additionally",1,"app-hover-link"]],template:function(r,n){1&r&&(e.TgZ(0,"section",0)(1,"h3",1),e._uU(2," API: GlnRegexCheck. "),e.TgZ(3,"a",2),e._uU(4,"#"),e.qZA()(),e.TgZ(5,"p"),e._uU(6," Selector: "),e.TgZ(7,"span",3),e._uU(8,"[glnRegexCheck]"),e.qZA()(),e.TgZ(9,"p"),e._uU(10," Exported as: "),e.TgZ(11,"span",3),e._uU(12,"glnRegexCheck"),e.qZA()(),e.TgZ(13,"p"),e._uU(14,' The directive checks the value of the input against the specified regular expression. If a mismatch is detected, then an error occurs with the "regexCheck" property. '),e.qZA()(),e.TgZ(15,"section",0)(16,"h4",4),e._uU(17," Properties. "),e.TgZ(18,"a",2),e._uU(19,"#"),e.qZA()()(),e.TgZ(20,"table",5)(21,"tr")(22,"th",6),e._uU(23,"Name"),e.qZA(),e.TgZ(24,"th"),e._uU(25,"Description"),e.qZA()(),e.TgZ(26,"tr")(27,"td")(28,"code"),e._uU(29,"@Input()"),e.qZA(),e.TgZ(30,"code"),e._uU(31,"glnRegexCheck: string | GlnRegexCheck | null;"),e.qZA()(),e.TgZ(32,"td")(33,"span"),e._uU(34,"A regular expression value or configuration object. "),e._UZ(35,"br"),e._uU(36," Examples of input value as regular expression: "),e.qZA(),e.TgZ(37,"ul")(38,"li")(39,"code"),e._uU(40,'glnRegexCheck ="^-?(\\d+)$"'),e.qZA()(),e.TgZ(41,"li")(42,"code"),e._uU(43,"[glnRegexCheck]=\"'^-?(\\\\d+)$'\""),e.qZA()(),e.TgZ(44,"li")(45,"code"),e._uU(46,'glnRegexCheck ="/^-?(\\d+)$/i"'),e.qZA()(),e.TgZ(47,"li")(48,"code"),e._uU(49,"[glnRegexCheck]=\"'/^-?(\\\\d+)$/i'\""),e.qZA()()(),e.TgZ(50,"span"),e._uU(51," An example of an input value as a configuration:"),e._UZ(52,"br"),e.TgZ(53,"code"),e._uU(54,' [glnRegexCheck]="{'),e._UZ(55,"br"),e._uU(56," 'Letters': '^(?=.*[a-zA-Z])[\\\\w\\\\W]{1,}$',"),e._UZ(57,"br"),e._uU(58," 'Digits': '^(?=.*\\\\d)[\\\\w\\\\W]{1,}$',"),e._UZ(59,"br"),e._uU(60," 'Symbols': '^(?=.*[!@#$%^&*])[\\\\w\\\\W]{1,}$'"),e._UZ(61,"br"),e._uU(62,' }" '),e.qZA()()()()(),e.TgZ(63,"section",0)(64,"h4",7),e._uU(65," Additionally. "),e.TgZ(66,"a",2),e._uU(67,"#"),e.qZA()(),e.TgZ(68,"p"),e._uU(69,' At the moment of creation, the "GlnRegexCheck" directive adds its validation function to the Form Control. This works great if it\'s a simple control. For example, the GlnInput component is a complex control. Since it has its internal control element (FormControl), to which all validation functions apply. It turns out that the "GlnRegexCheck" directive can pass its validation function only to the external implementation of the "GlnInput" component. And the internal control element of the "GlnInput" component will not know anything about the new validation function. As a result, the "GlnInput" component will not be able to correctly apply the new validation function. '),e.qZA(),e.TgZ(70,"p"),e._uU(71,' To solve this problem, a mechanism of interaction between the "GlnRegexCheck" directive and the "GlnInput" component has been implemented. The "GlnInput" component implements the provider with the "GRN_NODE_INTERNAL_VALIDATOR" token. The "GlnRegexCheck" directive, when created, gets an instance of this provider, if any. The provider instance has its own "GlnNodeInternalValidator" interface. This interface provides methods for adding validation functions. '),e.qZA(),e.TgZ(72,"ul")(73,"li")(74,"code"),e._uU(75,"addValidators(validators: ValidatorFn | ValidatorFn[]): void;"),e.qZA()(),e.TgZ(76,"li")(77,"code"),e._uU(78,"addAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;"),e.qZA()()(),e.TgZ(79,"p"),e._uU(80,' Thus, the "GlnRegexCheck" directive passes its check functions to the "GlnInput" component. And the "GlnInput" component in turn applies the new validation function to its internal control (FormControl). And everything works great. '),e.qZA()()),2&r&&(e.xp6(3),e.Q6J("href",n.urlDrRegexCheck+"#Api",e.LSH),e.xp6(15),e.Q6J("href",n.urlDrRegexCheck+"#properties",e.LSH),e.xp6(48),e.Q6J("href",n.urlDrRegexCheck+"#additionally",e.LSH))},styles:["app-dr-regex-check-api{display:block}\n"],encapsulation:2,changeDetection:0}),t})();function _(t,o){1&t&&(e.TgZ(0,"div",2),e._UZ(1,"app-dr-regex-check-basic")(2,"hr",3),e.qZA())}function k(t,o){1&t&&(e.TgZ(0,"div",4),e._UZ(1,"app-dr-regex-check-api")(2,"hr",3),e.qZA())}const Z="DirectivesRegexCheck",C=[{path:"",component:(()=>{class t{constructor(r){this.ngZone=r,this.showNum="",console.time(Z)}ngAfterViewInit(){Promise.resolve().then(()=>{U.R.scrollByFragmentFromPath()}),this.ngZone.onStable.pipe((0,T.P)()).subscribe(()=>{console.timeEnd(Z)})}}return t.\u0275fac=function(r){return new(r||t)(e.Y36(e.R0b))},t.\u0275cmp=e.Xpm({type:t,selectors:[["app-dr-regex-check"]],decls:6,vars:2,consts:[["id","Basic",4,"ngIf"],["id","Api",4,"ngIf"],["id","Basic"],["br-tp",""],["id","Api"]],template:function(r,n){1&r&&(e.TgZ(0,"h3"),e._uU(1,'Directives: "GlnRegexCheck"'),e.qZA(),e.YNc(2,_,3,0,"div",0),e.YNc(3,k,3,0,"div",1),e._UZ(4,"br")(5,"br")),2&r&&(e.xp6(2),e.Q6J("ngIf",!n.showNum||"01"===n.showNum),e.xp6(1),e.Q6J("ngIf",!n.showNum||"09"===n.showNum))},dependencies:[c.O5,f,A],styles:["app-dr-regex-check{display:block}\n"],encapsulation:2,changeDetection:0}),t})()}];let w=(()=>{class t{}return t.\u0275fac=function(r){return new(r||t)},t.\u0275mod=e.oAB({type:t}),t.\u0275inj=e.cJS({imports:[m.Bz.forChild(C),m.Bz]}),t})(),R=(()=>{class t{}return t.\u0275fac=function(r){return new(r||t)},t.\u0275mod=e.oAB({type:t}),t.\u0275inj=e.cJS({imports:[c.ez,b,v,w]}),t})()}}]);